필요한 리스트
전체, 흑, 백, 엣지

1차원
opend_defend_1 opend_attack_1 closed_defend_1
opend_defend_2 opend_attack_2 closed_defend_2
opend_defend_3 opend_attack_3 closed_defend_3
opend_defend_4 opend_attack_4 closed_defend_4

limited_opened or closed_attack or defend_1~3_4~2(1은 _4, 3은 _2)로 리스트 추가생성
or
좌표별 거리 상수 함께 전달

추가:closed_defend_4
2차원
22밴, 33밴, 22공격, 23공격, 33공격,공격시도 Lv1~3-->opend, closed도 각각

or

형태별 리스트 폐기하고 2차원리스트 운용
각 자리(좌표)에는 수의 종류들, lineN, 점수 합계 저장
이렇게 할 시 2차원 점검 함수는 1차원과 같이 거대 조건문 함수, 이 과정에서 새 2차원리스트와
전체리스트를 동시에 점검하는 경우가 생길 수 있음

점검 생략 알고리즘
-1차원 점검에서 한꺼번에 처리, 리스트에 넣어두고 매 반복마다 점검할지 그때그때 뺄지 결정

같은 라인 점수 중첩

0형태 자리
-2차원 점검에서 1차원 점검 지정
or
-각 개수 형태 조건문들에서 0형태 자리 추가 지정, 2차원 점검에서 조건 충족 시 해당 자리들에 추가 점수 부여

H, i형을 넘어서 아무것도 없는 자리에서 시도 수 몇개를 두어 강제로 3 이상을 만들 수 있다면?
-0형태 2번째 계획
-2차원리스트x, 클래스 형식으로 변경
-인스턴스 변수 동적 생성으로 각 좌표별로 좌표, 점수, 항목 넣기, 변수 이름은 globals("A13") 형식으로 지정

0형태 자리 종류

2차원 리스트 항목 형태

금수 예외 자리

3개 이상 점수 중첩 시 라인넘버 처리

라인넘버 구현
-튜플형식
-같은 라인 내 어느 좌표에서 라인을 호출해도 같은 형식이 나와야 함
-함수의 반환값으로 최소형태로 비교

유도 수가 쓰일 곳
-유도되는 자리가 공격 수를 방해하지 않아야 함.
-유도되는 자리가 상대의 금수 자리여야 함.

2차원 점검에서 공격 수들의 집합이 또다른 공격 수의 형태를 이룰 때의 경우
-위의 클래스 형식 적용
-수들의 집합(공격 수들, 놓여진 돌들로 구성)이 형태를 이룰 경우 분류 함수에서 또는 호출한 다른 분류 함수에서 
 추가 조건문을 통해 각 자리들의 점수 조정, 이 점검을 진행할 때는 1차원 점검 함수에 별도의 판별용 매개변수를 전달.
 1차원 점검때와 달리 함수에서 빈자리가 아닌 놓여진 돌들을 분류 함수로 전달
-수들의 집합이 2차원 공격 수의 형태를 이룰 경우를 위해 공격2(정확히는 절대점수 2 공격항목들) 형태의 빈공간들을
 임시로 저장해 뒀다가 다른 수와 겹치면 점수 추가

2차원 점검 때 점수가 높은 항목이 이미 존재하면 낮은 항목은 검토하지 않는 알고리즘(절대 점수 도입)
-점수는 절대점수, 1차원 기본점수, 2차원 가산점, 3차원 가산점으로 분류
-절대 점수 0 : 열린1 아래 모두 (대부분 수동적으로만 이용 가능한 수)
-절대 점수 1 : 열린1, 열린2, 닫힌2, 닫힌3, 일부 다차원 수 (능동적 설계 가능한 수)
-절대 점수 2 : (방어)열린3, 일부 다차원 수 (안막으면 짐)
-절대 점수 3 : (공격)열린3, 일부 다차원 수 (사실상 체크메이트)
-절대 점수 4 : (방어)닫힌4 (안막으면 짐, 공격3보다도 우선)
-절대 점수 5 : (공격)4 (게임 끝)
-절대 점수가 가장 높은 항목들을 점검 후 모두 미달이면 가장 높은 점수 저장 후 다음 점수 점검,
 해당 절대 점수에서 가장 점수 높고, 저장 점수보다도 높으면 해당 자리 선정, break,
 가장 낮은 수까지 반복, 이때까지 선정 못했을 시 저장 점수에 해당하는 자리 반환
-절대 점수 0인 수까지 모두 0개면 판 위 빈공간 랜덤 선정

2차원 점검 때 공격 수들의 집합이 2의 형태를 이룰 경우 시도 수 0단계 작업하는 과정 추가
-0형태 0단계 조건문 1차원 조건문에 추가, 위의 경우일 경우 해당 자리 점검

금수 자리가 겹칠 경우 금수 예외 자리가 하나 껴있어도 금수 처리
-겹친 모든 금수 자리를 점검했을 때 금수 자리가 둘 이상이면 금수 처리
.
유도 전략, 2차원 방어 전략 추가 구현 필요

3차원 점검 판별용 매개변수
-"탐색", "위험도검사", "금수검사" 등
-depth 수치별로 조건문 걸어서 다른 종류의 점검

-entire_list는 3차원 함수에 매개변수로 전달, 3차원 점검 때는 entire_list에 점검할 수를 더한 수를 전달.
 뒀던 수들 순서대로 저장할 리스트도 따로 생성

-attack, defense와 뒤의 숫자는 매개변수 분리, 이후 점수 계산 때 공격, 방어별로 분류하여 계산

-트리거, 타겟 알고리즘은 0형태에서가 아닌 기존 1,2 형태에서 추가
 0단계 - 열린 0, 닫힌 1
 1단계 - 열린 1, 닫힌 2

-2차원 점검에서 수 집합이 닫힌3 형태일 경우 나머지 2자리 0형태 점검
 공격단계 열린1급 이상이면 모두 적용 고려

-방어 자리에도 시도 수 알고리즘 적용하여 공격으로 막기 방법 고려

-분석 결과 같은 라인에서 2연속 빈자리가 있는 닫힌3 하나가 
  다른 빈공간 1 이상 닫힌3과 겹치면 44의 효과를 나타냄.
  -->다른 경우도 있음, 유도 수 적용하여 유도하는 곳이 다를 경우 추가 점수, 육목 경우 생각.

  2차원 클래스에서 특수 속성 추가하여 위와 같은 경우에만 추가 점수
  둘중 하나라도 열린 경우는 다른 케이스로 취급(육목에 의한 점수 삭제 고려하여 둘중 높은 점수)

-1차원 점검에서 높은 수 점검 시 낮은 수 자리들도 같이 점검하는 방안 고려

-트리거, 타겟 방식으로 육목 범위가 만들어지는 자리에 두면 기존 공격 수들 점수 삭제(3) or 하락(2)
 다른 트리거 타겟과 달리 바로 적용되는 점수가 아니기에 따로 보관하여 3차원에서 사용하는 방안 고려
 (VCT, VCF 점검 때 사용)

-방어 그룹 만들어서 상대의 2차원 공격이 형성되면 그 구성 요소들의 방어 자리 모두 추가 점수

-2차원 점검 때 2차원 공격 형성 시 구성 요소들의 0형태 자리 트리거 타겟 방식으로 점수 추가

-2차원 수들 공격, 방어 따로 모아둘지 합칠지 생각해보기

-트리거도 종류마다 이름 붙이고 타겟은 통일해서 생성

-classify에서 공격,방어 판별

-형태들 이름 리스트로 한꺼번에 클래스에 저장(opened,closed,narrow,empty_2,empty_3,trigger)

-클래스 딕셔너리, 클래스 좌표들이 저장된 리스트를 리턴-->2차원 함수에서 점검-->2차원 수 딕셔너리에 저장

-read_color,AorD는 더 상위 차원에서 가지고 들어오기

-흑, 백 분리하여 읽어서 금수만 간략하게 판별할 수 있도록 하기

-2차원 수 생성보다 금수 자리 점검을 먼저 해야됨

-5 점검 이전 6 점검부터 시작

-check_type과 AorD 통합
-->check_type -> run_mode로 변수명 변경

-3차원 금수자리 점검 시 전체적인 판의 상황과 상관없이 항상 고정적인 결과가 나와야 함 - 논리 재점검 필요
  (흑의 33자리가 다른 4 자리가 있다고 해서 금수로 안나오면 안됨)

-금수에 의해서 닫힌 자리 경우의 수

-inlist 함수 2차원의 1차원 점검 고려해서 구조 변경(모두 stone이면 False, 나머지 True)

-2차원의 1차원 점검 때 stone과 space가 한 세트일 경우, 그리고 이 경우 space를 무효처리해서 다른 형태로 보는 경우 
--> 일단 inlist에서 False를 리턴하는 것이 베스트, 안되면 notlist도 구조 변경, 이 경우에는 리스트 하나 추가 선언,
     추가 리스트는 inlist에서 매번 초기화
-space의 parents나 family가 점검 세트에 있을 경우 그 space와 같은 좌표값의 다른 space(공격 유효자리, 따로 모아서 전달)
 이 있으면 True, 없으면 False(다른 space도 parents, family 점검해야됨)
-notlist의 경우 위와 비슷한 점검을 해서 다른 space가 없으면 True, 있으면 False로 빈자리 취급

-거짓금수 판별 알고리즘 3차원이 아닌 2차원에서 구현, 1차원 점검에서 공격 수 판별할 때 next 항목 추가,
 next 항목들이 모두 금수 조건에 걸리지 않을 때까지 재귀함수나 while문 돌리기, 하나라도 걸리면 거짓금수
 이 next를 VCT, VCF에도 이용
--> (1)흑 공격2, 공격3 종합 -> (2)22, 33 종합 -> (3)구성요소 유도자리 점검(재귀)

테스트 : 22 자리의 2 중 하나의 유도 자리에 3이 걸침, 

-1차원 분류함수에 check_type도 전달하여 1차원 점검함수에서 추가 조건문 안 걸어도 되게 만들기

- 0형태 수 트리거, 타겟 모두 그 수 하나를 가리키게 하기

- 트리(재귀함수) 부분에서 상대가 대응 가능한 수라도 2개 이상 가지고 있으면 유효점수, 아니면 썩은가지 - 논리 재점검 필요

-금수유도 초기 단계에서 상대의 33 예상 지점에 포함된 공격 1들, 유도 지점 설계 자리 등등 모인 "project" 클래스 제작, 운용 고려
 -->기댓값 : 다차원 설계 수 초기 단계부터 체계적이고 원활한 점수 부여

-변수이름 AorD --> stance로 변경

- 2 * 막힌3과 같은 중첩된 1차원 수도 유도 수로 들어갈 수 있음

- 금수 유도 단계 3차원에서 다루기?

- edge 계산 따로

- run_mode 각 점검 사항
1차원 0형태 : 열린2 이하
금수 점검 1차원 : 열린2, 열린3, 닫힌3, 열린4, 닫힌4
일반 1차원 : 전부
일반 2차원 : 열린2 이상
2차원 0형태 : 열린2 이하

- run_mode 각 요구 사항
1차원 0형태 : 1차원 spaces (점검할 목록, 그 자리들의 라인튜플)
금수 점검 : 흑만 점검
일반 1차원 : 
일반 2차원 : 2차원 spaces
2차원 0형태 : 2차원 spaces

- notlist 2차원일때 열린2 미만 자리는 빈자리 취급

- 함수명 변경
 inlist -> include, notlist -> exclude

- D2_space 목록 : 일반 1차원+1차원 0형태, 일반 2차원+2차원 0형태, 금수

- 1차원에서 닫힌2, 열린1의 같은 라인에서 트리거, 타겟 생성

- 한 색깔 읽을 때 공격, 방어 수 전부 판별, 2차원 지점은 공격 지점 탐색했으면 그에 따라 방어 위치도 지정

- include 함수 옵션
entire turn 결정
option	turn	result
0(ally)	0(black)	0(black)
0(ally)	1(white)	1(white)
1(enemy)	0(black)	1(white)
1(enemy)	1(white)	0(black)
--> XOR 연산

2차원 점검시 value 결정
D2val	RT	D2check	result
0	0(D1)	0	1(true)	(케이스 없음)
0	0(D1)	1	1(true)	(케이스 없음)
0	1(D2)	0	0(false)
0	1(D2)	1	1(true)
1	0(D1)	0	1(true)
1	0(D1)	1	1(true)
1	1(D2)	0	1(true)
1	1(D2)	1	1(true)
--> D2val=D2val|(1-RT)|D2check
     D2val|=(1-RT)|D2check
--> D2val과 RT가 동시에 0인 케이스 없으므로 RT 생략
     D2val|=D2check
원래 문장
if D2check:
    D2val=True

- exclude 함수에서 2차원 수는 점검 x, 중간이 뚫린 형태의 흑 1차원 수는 별도 조건문 추가

- 13버전 Classify 함수 --> 14(현재)버전 set_space 함수

- 2차원 자리 점검 시 1차원 자리에는 트리거 발동, 새로 탐색한 자리는 추가 저장 + 그자리 기준 트리거 발동

- 1차원 점검 시 타겟이 같은 트리거는 한꺼번에 전달?

- setspace 필요 항목 : 우선순위 수치, 트리거 타겟, 패밀리

- 금수 자리만 제외하고 set_space에 전달하는 함수를 set_space 호출문 안에 넣기?
 -> 옵션 전달해서 1이면 ex_ban 함수 호출, 변수들 전달해서 자리들 추출

- 방어 단계 구축 : 공격 공간 완전 파괴(1), 열린 공격 차단(2), 부분적 방어(3)
- stance 항목에 DEFENSE2,3,4 추가
DEFENSE2 : 열린 공격 차단(닫힌 공격은 가능)
DEFENSE3 : 부분적 방어(열린 공격도 가능 or 닫힌 공격 여전히 가능)


- run_mode 0형태(trigger 탐색)일때만 방어0자리 탐색
- 인덱스 9,10자리는 7,8자리 not sixpoint 점검 (육목 위험 자리는 6번째 옆자리가 닫힌 것과 같음)
- trigger 자리 점검 시 방향 제외 3방향만 activate, 객체 내에 해당 리스트 구현 (ex : [1,1,0,1])
  이 리스트에 1이 아닌 선공권 수치 넣는 것도 고려
- DEFENSE 1,2,3 분할 전달 말고 2차원 리스트로 인덱스 한번에 넘기기  


_ _ _ E _ 0s _ Tr Ta _ _

9 7 5 3 1 0 2 4 6 8 10
0 1 2 3 4 5 6 7 8 9 10
_ E _ _ O op cl 2 _ _

_ _ _ _ O O _ O O _ O

_ O _ O O O O _ O _

_ _ A _ _ O _ O _ E _

- trigger, target 모두 space 점검 시 탐색, trigger가 유효한 자리와 겹치면 target들 space 타고 가서
  해당 space 다시 점검 (이미 점검했던 자리라도)

형태 판별 자동화 함수
- 오른쪽 네개 include ALLY 점검으로 선공권 수치 측정
- 가운데서부터 양쪽 바깥쪽으로 점검. (아래 점검 걸리면 반복 정지, 기록)
- 중심점, 가장 먼 ALLY 지점을 기준점으로 잡고 양쪽 sixpoint 지점 판별해서 닫힌 판정
  (include ENEMY -> 위 조건 만족시 sixpoint, not sixpoint -> exclude 점검?)
- 유효 공간이 연속 6개 이상일 때, 양쪽 맨 끝 제외하고 중심점으로부터 4칸 이하인 지점이 열린 자리
- 양 끝 중 하나가 ENEMY와 붙어있거나, 공간이 5칸이거나, 중심점으로부터 5칸인 지점들이 닫힌 자리
- 방어 1, 2, 3 기준 이후 추가 구현
- 유도 지점
- 육목 자리(4형태에서)
- 금수 자리 추가 탐색
 -- 범위 내 금수 모두 탐색, 각각 추적하여 현재 상황에서 해제 가능한지 판별
- 처음에 유효 공간 모두 닫힌 판정, 이후 6(4)공간 하나씩 점검해서 금수 없으면 열린 판정
- exclude check 끝나고 sixpoint 점검시 sixpoint조건에 걸리면 연쇄적으로 left,right 당기며 공간 삭제,
  exclude 자리 만나면 break #각각 반복 횟수 체크
- e_left, e_right (expanded index), r_left, r_right (reduced index) 따로 저장
 --> 이후 육목, 트리거, 방어 관련 로직에 이용
- exclude_check 함수에 expand 작업 시 exclude 함수 전달, reduce 작업 시 sixpoint 함수 전달
- 육목 위험 자리 방어목록에 넣을 때 단계 설정 체크
- 금수 해제 조건 : (흑 차례) and (parent 같음) and (prior_val 2일때 2*2 or 3일때 3*3) and (겹친게 두개) 
- 트리거, 타겟 재정리 (0형태 트리거만 그대로, 1형태, 2형태는 로직 변경)
 --> 유도 지점이랑 로직 같아짐. 통합하고 이후에 분류해서 사용
- 열린트리거 : 트리거, 타겟 둘다 열린범위 안에 있음
  닫힌트리거 : 열린 트리거 이외 모든 경우의 수

방어 분류
- DEFENSE1 : reduced 공간을 완전히 파괴하는 자리
- DEFENSE2 : DEFENSE1에서 reduced 공간에 열린 공격이 하나도 없으면 DEFENSE2로 분류

- DEFENES3 : 열린 공간을 완전히 파괴하는 자리
- DEFENSE4 : DEFENSE3에서 4개씩 읽은 열린 공간에 열린 공격이 하나도 없으면 DEFENSE4로 분류

- DEFENSE5 : 위 방어자리 제외 reduced 공간 내 모든 자리

- 같은 라인에서 점수가 중첩되는 경우는 트리거에 의해서만 (타겟이 다를 때)
- 모든 수에 0형태 트리거 읽기
- 연쇄 트리거 가능, 활성화 수치 전파, 역전파 필요
- 트리거의 parent?
- 트리거-타겟 객체의 통합 수치는 min(트리거,타겟)
- 연쇄 트리거 발동 시 (타겟 수치 -> 다음 트리거 수치) 형식으로 전이
- 역전파 시 (추가한 트리거에 다른 타겟이 겹쳐있을 때)
  다른 수와 같은 방식으로 해당 타겟 -> 추가된 트리거 점수 전이(그냥 그자리 제일 높은 수 전달)
- 흑이 6목 이상의 형태일 때 백이 defense4자리에 뒀을 때 역효과가 나는 현상

- 흑, 백 각각 max 선공권 구하기
- trigger-target, 2차원 수 등에서는 부분 선공권 구해서 계산
- get_ally 함수 2차원일 때는 last 기준으로 최대 5분할 후 별도 알고리즘 구현해서 계산

- multiple_filter OA_L 구할 때 ally_banL을 exceptL로 전달(두지 못하는 곳), 
  checked_banL을 checkL로 전달(4공간 안에 있어도 열린 상태가 풀리지 않는 곳)

- D2 딕셔너리 D1 부분에 parents 딕셔너리 추가, 이후 2차원 방어에 사용

- 한 parent를 읽었을 때, 같은 turn의 딕셔너리에는 공격 obj, 다른 turn에는 방어 obj 전달,
 이후 공격이 겹칠 때 각각의 방어 자리 parent 딕셔너리에서 찾아서 방어 구성

- union-find

- target의 부모 trigger가 2개 이상일 때, 연결이 약해진 쪽은 2차원 수, 0형태 등 activate 처리 후
  연결 상태 및 트리거 수치 가장 강한 쪽으로 전이

- parents 종속관계 해결 방안 : parents 한 지점씩 lineT와 묶어서 element들과 연결

- parents는 element class에서 좌표만 set으로 저장, 이후에 접근 시 합집합으로 특정 좌표의
  parents 모으고, 그 좌표들의 연관 속성 자리 찾기 - 점검

- parents 겹침 확인 함수 : 두 리스트 합 길이 == 합집합 길이

- 2차원 점검 시 같은 라인 수 허용(같은 부모 내 중복 불가능)

- 닫힌 트리거 3 유도 타겟 형식으로 트리거 지점 금수 해제 알고리즘 점검

- 현재 존재하는 최대 절대 점수에 따라 활성화하는 트리거 범위 조절

- 트리거는 linear_nest 처리 후 활성화된 자리만 그래프 탐색

- 트리거 x normal : 절대등급(prior_val + 1, 속성)이 높아지는 쪽으로는 활성화 X
		
- 트리거 x 트리거 : 같은 등급 normal 수 겹침 처리, turn에 따라 33, 44, 43 빌드
		(겹침처리 먼저 하고 변경된 수치를 target에 전달하기 위함)

- 같은 turn 두 수가 겹치면 절대등급이 더 낮은 쪽에 강제성이 부여,
  해당 자리는 max(현재등급, 절대등급(낮은쪽 prior_val + 1, 나머지 속성)-1.5) 처리
  -> max(현재등급, 절대등급(min(양쪽 predict_abs))-2)

- 활성화 : 트리거 자리와 동일한 속성을 target 객체로 만들어 해당 좌표에 저장, 
	 parents_nest 처리, 이후 행렬에 normal 수와 동일하게 카운트,
	 전달받은 속성의 parents는 trigger와 동일

- normal과 target은 상호작용 X, 같은 종류끼리만 parents_nest 수행

- 1차원 방어 판별 전용 left, right 따로 구현 (exclude_check 시 ally 도 빈자리 취급)

- analyzer_v2 파일 추가, 이동

- 1차원 트리거 판별 시 해제 가능한 금수 자리 있으면 트리거 자리에 넣기

- 1차원 turn, stance에 따른 exceptL의 banL 포함 관계 다시 체크
 -> defense4 자리가 실존하는지 체크

- 1차원 해제 가능 금수 동작 다시 확인

- abs_score -> abs_value로 변경 고려

- 1차원 보조함수들 p, dp 사용하던거 클래스로 제작, 직관적으로 표현(변수명 따로 생각)

- Space 객체변수에 objL 다시 추가, 1차원 점검 시 add_element가 아닌 add_obj로 parents_nest
  동작만 진행
 -> add_element는 Dimension_2로 이동(각 key 좌표 space의 objL에 접근)

- get_sort_key 함수 추가
 -> return lambda e:(e.prior_val,-e.shape)
 -> sorted 부분 전체를 함수화하는 것도 고려

- distribute_space -> set_indexL_option 이름 변경, 각 indexL마다 parameter obj 묶어서 반환
 

- set_D1_normal -> set_D1_element 이름 변경

- Parents 
 -> Element 클래스 메소드로 get_parents_key 추가, self.lineT[2], self.parents로 Parents 객체 value 접근

- D2_spaces -> turn_dict=SPACE_DICTS(),SPACE_DICTS()
 -> turn_dict는 (BLACK space_dicts, WHITE space_dicts) 형태 튜플, 기존처럼 상수 인덱싱으로 접근
 -> turn_dicts[turn] -> space_dicts (매개변수 전달 시 이름 변환)
  ex) turn_dict[turn].D1[xyT].add_element(new_e)
       space_dicts.D1[xyT].add_element(new_e)
 - space_dicts 요소에 entire 요소 넣어서 통합 관리하는 것 고려(3차원에서 사용 가능성)
 - ban_check에서는 ban_dicts=SPACE_DICTS()로 하나만 생성하여 space_dicts 자리에 전달?
 -> 2차원 함수에서 상대 turn의 dicts에 접근하는 요소 있으면 원래대로 turn_dict 한꺼번에 전달

- 2차원 normal_nest predict_abs 비교값 min 계산 다시 체크
- activate 조건(전체 max abs와 비교)과 실질적 value를 분리
 ex) 33과 34는 실질적 value가 같으나 activate 조건은 34가 높음
 -> 기본 점수와 이외의 최소 점수를 2보다 크게 이격, predict_abs에서 2를 뺀 값 사용(닫힌 속성 해제)
 -> space1,space2=sorted((space1,space2),key=lambda x:x.abs)
 -> max(origin_abs(space),min(predict_abs(space_1),predict_abs(space_2)-2))
 -> 2는 같은 stance의 한 단계 높거나 낮은 abs와의 차이, 이 수치 변경 시 위의 공식에서도 같이 변경
     (변수 혹은 상수로 지정 고려)
 -> 공격, 방어 5에 대한 abs도 구현 (predict_abs 계산 용도)
 - 방어 abs 부여 시 같은 family에 대해서는 동일한 수치로 설정
 -> 이후 방어 target과 같은 추가적인 수치 변화 주는 것 고려
 -> 취소, 이미 겹치는 자리는 1차원적 표현된 상태, abs에 따른 1차원 수치 의미는 학습에 맡길 것

- 2차원 열린 공간(4칸)씩 읽어서 먼저 판별, 이후 5칸씩 읽어서 닫힌 자리 판별, nest

- 3중첩 이상 특수 형태 방어 알고리즘
 -> 해당 자리는 defense5 자리가 아닌 열린 공격 -> 방어 전환 자리
 -> origin_abs가 기본 점수일 때만 적용?
 -> defense 1~4끼리 겹친 형태라도 3중첩 자리의 abs를 올리는 로직 필요
 -> 3차원을 공격/방어로 분리?

linear_nest 처리
- 닫힌 트리거 3 -> 타겟이 일치하지 않을 때 *트리거 자리* 44 처리(흑은 금수)
- 트리거 겹쳤을 때, 양쪽 모두 타겟 차집합 공간이 1개 이상이어야 하고, 
  5공간 내에서(트리거자리 제외) 닫힌3을 만들 수 있으면,
  닫힌 3을 만드는 타겟자리 + 차집합 공간 자리(2개 이상이면) 활성화
- 

run_mode, element_type 종속관계 해결 - 취소
- unpack_indexL의 run_mode에 따른 함수 분류 기능 윗단계로 이동(distribute_space)
- distribute_space 함수 dp변수 전달 방식이 아닌 리턴 방식으로 전환 (함수 이름도 변경)



trigger-target 그래프 탐색 - DFS

* visited 변형
- 최초 탐색 이전 모든 (trigger 좌표, target 좌표) 쌍들을 set에 저장
   (이론상 최대 4*2*2*4*225=14400개 -> set 변수 메모리=512kb)
- while set 조건으로 반복
- 탐색 지점 (trigger 좌표, target 좌표) 한 쌍을 set에서 삭제
- 특정 좌표에서 점수 갱신 시, 해당 좌표의 (trigger,target), (target,trigger) 쌍들을 다시 set에 삽입

* 원형 수치 전달 방지
- 현재 (trigger,target)이 set에 없으면 현재 탐색루트 종료
- 탐색 루트 순서대로 (parents, trigger-target 수치 리스트) 다음 루트로 전달
- 현재 지점 parents가 탐색 루트 parents에 존재하면 (전달 리스트)[존재 지점:] 슬라이싱

* 추가 구현 필요
- parents 탐색 알고리즘
- trigger-target 통합 수치
 -- 수치 계산(수치 계산(수치 리스트) + new 수치)) 와 수치 계산(수치 리스트 + new 수치)
    결과가 같은가? 
- 탐색 목적이 수치 저장, 나중에 계산이면 각 지점마다 (수치,depth)들 set으로 저장,
  위 슬라이싱 방식 적용
- 탐색 목적이 수치 갱신이면?
- trigger -> target 갱신됐을 때, target -> trigger 탐색이 반드시 다시 필요한 지 점검
- 점검 조건 parents, lineT 모두 고려해야 하는지 점검

남은거
저단계 3차원 알고리즘
-한 장면마다 어떤 상황인지 판단할 근거 필요
-특정 근거를 기준으로 레벨 정하고 다음 수에 레벨 하락 시 점수 낮추기
  (같은 절대점수 수들이 모두 하락일 경우도 고려해야 함)
-VCT, VCF 지속 가능 여부, 위 3차원 점검 항목들, 자리에 뒀을 때 기존 나, 상대의 공격 가능 수 개수 비교,
 VCT, VCF로 발전 가능성 체크
6목
-트리거, 타겟 방식으로 육목 범위 안에 있으면 점수 낮추기(해당 라인에서 점수 삭제)
 반대로 금수 유도 상황일 경우 역이용해서 적용

유도수
날일진 방어법
공격 개시 스택 기준
1차원 nt매개변수 삭제, 육목 고려 거대 조건문 재구성
다차원에서 라인넘버 겹치는 경우
2차원 방어 전략
-상대의 2차원 공격 때 방어 가능한 모든 자리에 점수 추가

첫수부터 3수까지만 특수 알고리즘 적용하는 방식

3차원
  ↓호출
2차원
  ↓호출
1차원
  ↓호출
분류

def D_3(순서,판별,depth,entire_list)
    2차원 호출
    장면 판별,

평균 n수까지 읽는다고 가정하면
-평균 비교대상 수^(n+1)
-ex) 평균 동일 2차원 점수 자리 10개, 5수 앞까지 읽음
      --> (1,000,000*(코드 실행 횟수(500이라 가정))/10,000,000)초 -->50초 

-ex) 2수부터 시작, VCT 5회 진행, VCT 평균 동일점수 3, 이후 2개 진행
      --> 8*10*3*3*3*3*3*2=38880(경우의수)